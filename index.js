

// Экранирование буквенных кавычек в строках

// Чтобы добавить кавычки в js код и они отобразились, т.е написать буквальную цитату. Нужно перед ними добавить косую черту /" 

const myStr = "I am a \"double quoted\" string inside \"double quotes\".";
console.log(myStr); // => I am a "double quoted" string inside "double quotes".
const myStr = '<a href="http://www.example.com" target="_blank">Link</a>'; // двойные кавычки внутри одинарных

/* 
Специальные символы для того чтобы js вывел их на экран
Код	Выход
\'	одинарная кавычка
\"	двойная кавычка
\\	обратная косая черта
\n	новая линия
\r	возврат каретки
\t	вкладка
\b	граница слова
\f	подача формы
*/

// Конкатенация +

const ourStr = "I come first. " + "I come second."; // => I come first. I come second 

// также в конкатенации можно использовать оператор +=

let ourStr = "I come first. ";
ourStr += "I come second."; // => I come first. I come second 

// Также можно вставлять переменные в строку с помощью +

const ourName = "freeCodeCamp";
const ourStr = "Hello, our name is " + ourName + ", how are you?";

const anAdjective = "awesome!";
let ourStr = "freeCodeCamp is ";
ourStr += anAdjective; // или вот так, ourStrбудет иметь значение freeCodeCamp is awesome!.

// длина строки 
//Вы можете найти длину Stringзначения, написав .length после строковой переменной или строкового литерала.

console.log("Alan Peter".length); //=> 10

/* В JavaScript String значения являются неизменяемыми, что означает, что их нельзя изменить после создания.

Например, следующий код:
*/

let myStr = "Bob";
myStr[0] = "J";
//не может изменить значение myStrна Job, потому что содержимое myStrне может быть изменено. Обратите внимание, что это не означает, что myStrего нельзя изменить, просто нельзя изменить отдельные символы строкового литерала . Единственный способ изменить myStrэто — присвоить ему новую строку, например:

let myStr = "Bob";
myStr = "Job";


//!-----------------------------------------------------------------------------------------------------------------------------------------------



//! МАССИВЫ

const sandwich = ["peanut butter", "jelly", "bread"];

// Вы также можете вкладывать массивы в другие массивы, как показано ниже:
// Это также называется многомерным массивом .



const teams = [["Bulls", 23], ["White Sox", 45]];

//?Мы можем получить доступ к данным внутри массивов, используя индексы .
//?Индексы массива записываются в той же скобочной нотации, что и строки,за исключением того,
//?что вместо указания символа они указывают запись в массиве. Как и строки, массивы используют индексацию с отсчетом от нуля , поэтому первый элемент в массиве имеет индекс 0.

const array = [50, 60, 70];
console.log(array[0]);
const data = array[1]; // => 50

//! В отличие от строк, элементы массивов изменяемы и могут свободно изменяться, даже если массив был объявлен с расширением const.

//Пример:

const ourArray = [50, 40, 30];
ourArray[0] = 15;

//? ourArrayтеперь имеет значение [15, 40, 30].

/*
Один из способов представить многомерный массив — это массив массивов.
Когда вы используете скобки для доступа к вашему массиву, первый набор скобок относится к записям в самом внешнем (первом уровне) массиве,
а каждая дополнительная пара скобок относится к следующему уровню записей внутри.

Пример */

const arr = [
    [1, 2, 3],
    [4, 5, 6],
    [7, 8, 9],
    [[10, 11, 12], 13, 14]
];

/*
arr[3];
arr[3][0];
arr[3][0][1];
arr[3]есть [[10, 11, 12], 13, 14], arr[3][0]есть [10, 11, 12]и arr[3][0][1]есть 11.
*/


//!Простой способ добавления данных в конец массива — через push()функцию.

/*
.push()принимает один или несколько параметров и "помещает" их в конец массива.

Примеры:
*/

const arr1 = [1, 2, 3];
arr1.push(4);

const arr2 = ["Stimpson", "J", "cat"];
arr2.push(["happy", "joy"]);

//? arr1 теперь имеет значение [1, 2, 3, 4]и arr2 имеет значение ["Stimpson", "J", "cat", ["happy", "joy"]].

//! Другой способ изменить данные в массиве — использовать .pop()функцию.

/* .pop()используется для извлечения значения из конца массива. Мы можем сохранить это всплывающее значение, назначив его переменной. Другими словами, .pop()удаляет последний элемент из массива и возвращает этот элемент.

Любой тип записи может быть извлечен из массива — числа, строки и даже вложенные массивы.
*/

const threeArr = [1, 4, 6];
const oneDown = threeArr.pop();
console.log(oneDown);
console.log(threeArr);

//? Первый console.log отобразит значение 6, а второй отобразит значение [1, 4].

//! метод .shift() работает как и .pop(), но удаляет первый элемент массива, а не последний.

сonst ourArray = ["Stimpson", "J", ["cat"]];
const removedFromOurArray = ourArray.shift();

//? emovedFromOurArrayбудет иметь значение строки Stimpson, и ourArrayбудет иметь ["J", ["cat"]].


//! unshift()работает точно так же .push(), но вместо добавления элемента в конец массива unshift()добавляет элемент в начало массива.

//Пример:

const ourArray = ["Stimpson", "J", "cat"];
ourArray.shift();
ourArray.unshift("Happy");

//? После shift, ourArrayбудет иметь значение ["J", "cat"]. После unshift, ourArrayбудет иметь значение ["Happy", "J", "cat"].

//! создадим массив в переменной myList со спискjv продуктов и с номерами им соответсвующими (рандомно)

const myList = [
    ["banana", 5],
    ["coffe", 12],
    ["cola", 55],
    ["cheese", 76],
    ["milk", 6]
];


//!========================================================================================================================
//**************************************************************************************************************************/
//!========================================================================================================================

//!\****************ФУНКЦИИ*************************\

//В JavaScript мы можем разделить наш код на многократно используемые части, называемые функциями .

//Вот пример функции:

function functionName() {
    console.log("Hello World");
}
functionName() // Вызов функции.

//?Вы можете вызвать или вызвать эту функцию, используя ее имя, за которым следуют круглые скобки,
//?например: functionName();Каждый раз, когда функция вызывается, она выводит сообщение Hello Worldна консоль разработчика.
//?Весь код между фигурными скобками будет выполняться каждый раз при вызове функции.

// Фактические значения, которые вводятся (или «передаются» ) в функцию при ее вызове, называются аргументами, ниже приведена функция с двумя параметрами
// в аргументы можно передавать разные значения, сколько угодно раз. 

function testFun(param1, param2) {
    console.log(param1, param2);
}

//? Функция должна что-то возвращать, чтобы вернуть значение из функции нужно использовать оператор return. Пример ниже.


function plusThree(num) {
    return num + 3;
}

const answer = plusThree(5); // answer = 8; т.к в аргумент мы передали число 5 (5 + 3 = 8 )

//! Но использование  return в функции не обязательно, в случаее если у функции нет return инструкции, при её вызове функция обрабатывает внутренний код, но возвращаемое значенние будет равно undefined

let sum = 0;

function addSum(num) {
    sum = sum + num;
}

addSum(3);

// addSum это функция без return оператора. Функция изменит глобальную sum переменную, но возвращаемое значение функции равно undefined.

//!Переменные, объявленные внутри функции, а также параметры функции имеют локальную область видимости. Это означает, что они видны только внутри этой функции.

function myTest() {
    const loc = "foo";
    console.log(loc);
}

myTest();
console.log(loc);

//* Вызов myTest() функции отобразит строку foo в консоли. Строка console.log(loc)(вне myTest функции) выдаст ошибку, так как loc не определена вне функции.

//! Можно иметь как локальные , так и глобальные переменные с одинаковыми именами. При этом локальная переменная имеет приоритет над глобальной.

const someVar = "Hat";

function myFun() {
    const someVar = "Head";
    return someVar;
}

//* Функция myFun вернет строку, Head поскольку присутствует локальная версия переменной.




///! Операторы IF ELSE 

//?if Операторы используются для принятия решений в коде. Ключевое слово if указывает JavaScript выполнять код в фигурных скобках при определенных условиях, определенных в скобках. Эти условия известны как Booleanусловия, и они могут быть только trueили false.

//?Когда условие оценивается как true, программа выполняет оператор внутри фигурных скобок. Когда логическое условие оценивается как false, оператор внутри фигурных скобок не будет выполняться.

/*/Псевдокод

если ( условие истинно ) {
  оператор выполнен
}
*/
function test(myCondition) {
    if (myCondition) {
        return "It was true";
    }
    return "It was false";
}

//*est(true)возвращает строку It was trueи test(false)возвращает строку It was false.
//*Когда testвызывается со значением true, ifоператор оценивает myCondition, так это trueили нет. Поскольку это так true,
//*функция возвращает значение It was true. Когда мы вызываем testсо значением false, неmyCondition выполняется и оператор в фигурных скобках не выполняется и функция возвращает значение . true It was false

//! Операторы сравнения

//? В JavaScript существует множество операторов сравнения . Все эти операторы возвращают логическое значение true или false значение.
//? Самый простой оператор — это оператор равенства ==. Оператор равенства сравнивает два значения и возвращает true, эквивалентны false они или нет.
//? Обратите внимание, что равенство отличается от присваивания ( =), которое присваивает значение справа от оператора переменной слева.

function equalityTest(myVal) {
    if (myVal == 10) {
        return "Equal";
    }
    return "Not Equal";
}

/*
Если myValравно 10, оператор равенства возвращает true, поэтому код в фигурных скобках будет выполнен, и функция вернет значение Equal.
В противном случае функция вернется Not Equal. Чтобы JavaScript мог сравнить два разных типа данных (например, numbersи strings),
он должен преобразовать один тип в другой. Это известно как приведение типа. Однако, как только это произойдет, он может сравнивать термины следующим образом:

1   ==  1  // true
1   ==  2  // false
1   == '1' // true
"3" ==  3  // true
*/

//! Строгое равенство ( ===) является аналогом оператора равенства ( == ). Но ихъ отличие в том что строгое неравенствол не осуществляет преобразование типов,
//!т.е "3" === 3 вёрнет false, а если мы бы использовали "==", то значения сперва бы привелись к одному типу данных, а потом сравнились, вернулось бы true.

//! Чтобы определить тип значения или переменной нужно использовать оператор typeof 
/*
typeof 3
typeof '3'
typeof 3возвращает строку numberи typeof '3'возвращает строку string.
*/

//! Оператор неравенства !=
/*
Оператор неравенства ( !=) противоположен оператору равенства.
Это означает не равно и возвращает falseто, что вернулось бы к равенству, trueи наоборот.
Как и оператор равенства, оператор неравенства преобразует типы данных значений при сравнении.
*/

1 != 2    // true
1 != "1"   // false
1 != '1'   // false
1 != true  // false
0 != false // false

/*
Оператор строгого неравенства ( !==) является логической противоположностью оператора строгого равенства.
 Это означает «Строго не равно» и возвращает результат falseтам, где возвращалось бы строгое равенство,
  true и наоборот . Оператор строгого неравенства не будет преобразовывать типы данных.
*/

3 !== 3  // false
3 !== '3' // true
4 !== 3  // true

//!Оператор «больше чем» ( > ) сравнивает значения двух чисел. Если число слева больше числа справа, возвращается true. В противном случае возвращается false.

//Как и оператор равенства, оператор «больше чем» будет преобразовывать типы данных значений при сравнении.


5 > 3  // true
7 > '3' // true
2 > 3  // false
'1' > 9  // false

//!Оператор больше или равно ( >= ) сравнивает значения двух чисел. Если число слева больше или равно числу справа, возвращается true. В противном случае возвращается false.

//Как и оператор равенства, оператор больше или равно будет преобразовывать типы данных при сравнении.


6 >= 6  // true
7 >= '3' // true
2 >= 3  // false
'7' >= 9  // false

//!Оператор меньше чем ( < ) сравнивает значения двух чисел. Если число слева меньше числа справа, возвращается true. В противном случае возвращается false. Как и оператор равенства, оператор меньше преобразует типы данных при сравнении.

2 < 5 // true
'3' < 7 // true
5 < 5 // false
3 < 2 // false
'8' < 4 // false

//Меньше либо равно <= аналогично >=

//! оператор И &&
//?Иногда вам нужно будет протестировать более одной вещи за раз. Логический оператор and&& ( ) возвращает true значение тогда и только тогда, когда операнды слева и справа от него истинны.
//?Тот же эффект может быть достигнут путем вложения оператора if внутрь другого оператора if:

if (num > 5) {
    if (num < 10) {
        return "Yes";
    }
}
return "No";

// аналогично 

if (num > 5 && num < 10) {
    return "Yes";
}
return "No";

//!Логический оператор or || ( ) возвращает trueзначение, если один из операндов равен true. В противном случае возвращается false.

//Логический оператор or состоит из двух символов вертикальной черты: ( || ). Обычно это можно найти между клавишами Backspace и Enter.
//Шаблон ниже должен выглядеть знакомым по предыдущим путевым точкам:

if (num > 10) {
    return "No";
}
if (num < 5) {
    return "No";
}
return "Yes";

//вернется, Yes только если numнаходится между 5и 10(включая 5 и 10). Та же логика может быть записана как:

if (num > 10 || num < 5) {
    return "No";
}
return "Yes";


//! Оператор else 
//? когда условие для if оператора истинно, выполняется блок кода, следующий за ним. Что делать, если это условие ложно? Обычно ничего бы не случилось. С elseоператором может быть выполнен альтернативный блок кода.

if (num > 10) {
    return "Bigger than 10";
} else {
    return "10 or Less";
}

//! Если есть несколько условий то можно использовать else if вместе 

if (num > 15) {
    return "Bigger than 15";
} else if (num < 5) {
    return "Smaller than 5";
} else {
    return "Between 5 and 15";
}
